# Trustno1

## Introduction
Trustno1 is an IoT middleware that guarantees data privacy using SGX enclaves. Clients (Things and users) exchange messages with the enclave using a REST API, encrypting encrypting all messages containing meaningful information so that no other party, including the server hosting the enclave, can read them. Intel provides a mechanism to attest that a client communicates with a genuine SGX enclave, containing the code and data it claims. 

## General Communication Protocols
The following protocol descriptions are generic, they can be used as-is for the front-end app. Messages are exchanged with the enclave using encryption over HTTP requests. Message encryption at the application layer is needed because the classical TLS encryption used by most for HTTP only ensures data confidentiality of exchanges up to the server, which in our system is an untrusted component. Application-layer encryption allows us to communicate securely up to the secure application running in the SGX enclave. 
The system uses JSON notation along with base64url encoding (to represent binary data). Note that spaces are allowed in JSON data structures (e.g. {"test": 1} and {"test":1} are both valid), and that base64url encoding gets rid of the "=" padding at the end of the representation (i.e. no "....==="). The Additional Authenticated Data (AAD) of encrypted messages are normally not included in the request (they are provided by the untrusted server to the enclave).

## Session Key Establishment 
In order to use symmetric encryption, a symmetric session key must be defined. The system uses Ephemeral ECDH (ECDHE) for this. Ephemeral means that the session key should not be stored permanently by the client. This ensures Perfect Forward Secrecy (PFS), so that if an attacked recorded each message exchange and came into possession of the client's entire information (private key or current session key), it could only decipher at most the messages that have been encrypted using the current session key, but could not decrypt previous ones. 
The key exchange protocol is an adaptation of the one proposed the the COAP protocol, called ECDHOC which also requires application-layer encryption. This protocol is based on the SIGMA-I protocol. 
Here are a few notes about the key exchange: 
- The exchange is loosely based on the ECDHOC draft specification 
- The key session establishment requires two requests from the client. 
- The ECC curve used to generate key pairs is the NID_X9_62_prime256v1 curve (also referred to as secp256r1). 
- Because the JSON messages are used as AAD, they must use a compact serialization, meaning no whitespaces between keys and values "key:value", no indentation, no line or carriage return. In addition, they must be used in the same order as they were received. All schemas described here use an invalid, more human-readable format.
- The symmetric encryption uses AES GCM 256 bits. The key size is 256 bits, the IV size is 96 bits and the tag length is 128 bits.
- The shared key is not used as is, it is instead used to derive keys. The key derivation algorithm is HKDF, using SHA-256 as the key derivation function. 
- The hash function is SHA-256. 
- The digital signature is ECDSA. 
- All binary values shown in the examples are in their hexadecimal representation.
#### Example
An example of each message is shown below. For this, we assume the following: 
- The id of the client doing the exchange is 1.
- The fixed private key of the server is (in hexacdecimal form): B5E1CFEB2CB0D28DC1D12AE515BBEA4D4D0AAEE07CFEDC51A4EA1AEB08ED9D00
- The fixed private key of the client is (in hexacdecimal form): 43EE1E275B214845A575A118A07798EDD83E2620225C1EEA39A3AB307201B0ED

### Request 1 (Message 1)

#### HTTP Request
This is a POST request to /clients/\<clientId\>/keyExchangeStart. This message initiates the ECDHE exchange. 
```
{
	"clientExchangeId": BASE64URL_ENCODE(<client exchange id>),
	"nonce": BASE64URL_ENCODE(<nonce>),
	"clientPubKey": {
		"x": BASE64URL_ENCODE(<x coordinate>),
		"y": BASE64URL_ENCODE(<y coordinate>)
	}
}
```
The clientExchangeId is a 4 bytes unique and random value that is stored by the client and the enclave for the duration of the protocol. 
The nonce is a 8 bytes unique and random value. 
The clientPubKey is an object composed of the x and y coordinates of the ephemeral public key of the client. 

#### Message Generation
The message 1 is generated by the client by following these steps: 
- Generate a random 4 bytes value for the client exchange id and encode it. 
- Generate a random 8 bytes nonce value and encode it.
- Generate a new EC private/public key pair. Extract the x and y coordinates of the public key point and encode them.

#### Example: 
- Generate client exchange id: 876A306F.
- Generate nonce: F2C8CAA1184E9FE7.
- Generate new key: 
	- The private key is 8FC28808F60C63F95E9E0025F730E154376E423D63EA37214D199A379F5635EA.
	- The x coordinate is 2F48B4F13E167892A065168C967568B0236723AB3371554921246A1E1D98D554.
	- The y coordinate is F6AE0EA7C9B2E5C0775D3E4EA78DDE365BE3AAFF8C9B63894FAD006450F95F09.
- Encode the message, yielding (order and compact form is required): 
	```
	{"clientExchangeId":"h2owbw","nonce":"8sjKoRhOn-c","clientPubKey":{"x":"L0i08T4WeJKgZRaMlnVosCNnI6szcVVJISRqHh2Y1VQ","y":"9q4Op8my5cB3XT5Op43eNlvjqv-Mm2OJT60AZFD5Xwk"}}
	```
- This JSON object is sent as the payload to the HTTP request POST /clients/1/keyExchangeStart.

### Response 1 (Message 2)
Here is the structure of the response from the server.
```
{
	"unprotected": {
		"clientExchangeId": BASE64URL_ENCODE(<client exchange id>),
		"serverExchangeId": BASE64URL_ENCODE(<server exchange id>),
		"nonce": BASE64URL_ENCODE(<nonce>),
		"serverPubkey": {
			"x": BASE64URL_ENCODE(<x coordinate>),
			"y": BASE64URL_ENCODE(<y coordinate>)
		}
	},
	"ciphertext": BASE64URL_ENCODE(<ciphertext>),
	"tag": BASE64URL_ENCODE(<tag>)
}
```
The clientExchangeId is the one received in the previous message.
The serverExchangeId is a 32 bits integer value randomly generated and stored by the server, that uniquely identifies the exchange.
The nonce is a 64 bits new, unique and random value. 
The serverPubKey is an object containing the x and y coordinated of ephemeral public key of the client.
the tag is generated by the encryption.
The **ciphertext** is the encrypted message which in its decrypted form is of the form:
```
{
	"r": BASE64URL_ENCODE(<r>),
	"s": BASE64URL_ENCODE(<s>)
}
```
The signature consists in the AAD2 value, signed with the permanent private key of the server and encoded using the two "r" and "s" values of the signature.
The status code sent by the server is 200, or 401 if the \<clientId\> does not correspond to an registered client. 

#### Message generation
The message 2 is generated by the server by following these steps: 
- Generate a random 4 bytes value for the server exchange id and encode it. 
- Reuse the client exchange id received and encoding it. 
- Generate a random 8 bytes nonce value and encode it.
- Generate a new EC private/public key pair. Extract the x and y coordinates of the public key point and encode them. 
- Calculate the shared key from the ephemeral public key of the client and the ephemeral private key of the server. 
- Define the AAD2 as SHA256(\<message 1\> | \<unprotected message 2\>). The entire message 1 is concatenated with the "unprotected" object of the second message. 
- Generate the signature, extract the "r" and "s" elements, encode it in base64url and create the JSON object with it, in a compact format. The signed data is the AAD2, and is signed with the (permanent) private key of the server. 
- Generate the data encryption:
	- Derive a key of length 256 bits from the shared key using HKDF with no salt, and the context info: "GCM256ENCRYPTION" | BASE64URLENCODE(\<AAD2\>). ( | represents concatenation). 
	- Derive an IV of length 96 bits using the same method and the same shared key with context info "IV-GENERATION" | BASE64URL_ENCODE(\<AAD2\>).
	- Use the AAD2 generated above as the encryption AAD. 
	- Encrypt the signature object (in compact form), encode it in base64url format, and put it in the JSON object.
	- Add the base64url encoded tag of the encryption (it is of size 128 bits).

#### Example
The server does the following: 
- Generate client exchange id: 4B65606B.
- Generate nonce: A2867D53476BC942.
- Generate new key: 
	- The private key is 17D99B2A5473CE96CAD22815B01B4DC107396B856334B52413904F16C9867AC3.
	- The x coordinate is E4D49E9BF1C4AFDD714827650171EB9C6867997148717D3E56322158178505E8.
	- The y coordinate is 807EDBAEAFEAD27796816257C6BA82799C6D5AF99FB4CE7692841664D41062BF.
- Calculate the shared secret: 5F37F8C58BB59A9A6F37B82B831E3834B1956C9265A83013040A53405FB2F32B.
- Calculate the AAD2 by using SHA256 on the string
	 ```
	{"clientExchangeId":"h2owbw","nonce":"8sjKoRhOn-c","clientPubKey":{"x":"L0i08T4WeJKgZRaMlnVosCNnI6szcVVJISRqHh2Y1VQ","y":"9q4Op8my5cB3XT5Op43eNlvjqv-Mm2OJT60AZFD5Xwk"}}{"clientExchangeId":"h2owbw","serverExchangeId":"S2Vgaw","nonce":"ooZ9U0dryUI","serverPubKey":{"x":"5NSem_HEr91xSCdlAXHrnGhnmXFIcX0-VjIhWBeFBeg","y":"gH7brq_q0neWgWJXxrqCeZxtWvmftM52koQWZNQQYr8"}}
	```
	The string is shown here without surrounding quotes.  
	- The resulting AAD2 is 5328D1A934369FF7628A66D528004B212B06BFB083F4BA9CABB2B4C731AA62D5.
- Sign the AAD2 with the main private key. The signature cannot be determined in advance, so only an example of possible values is shown: 
	- "r" is 1639A51F3B40E030A446535052DF913240D51FAB7F31FF90DCB1D87032F35C93.
	- "s" is 08609EFC4DEC4F8DEF76A84F6F2F62A7C993823017119B32180283C02863A6B1.
	- The resulting JSON object is (order and compact form are required):
		```
		{"r":"FjmlHztA4DCkRlNQUt-RMkDVH6t_Mf-Q3LHYcDLzXJM","s":"CGCe_E3sT43vdqhPby9ip8mTgjAXEZsyGAKDwChjprE"}
		```
- Encrypt the signature object:
	- Derive an encryption key using the shared secret as secret, and "GCM256ENCRYPTIONUyjRqTQ2n_diimbVKABLISsGv7CD9Lqcq7K0xzGqYtU" as info (in this text form!). The resulting encryption key is 65383BD96E4A58D3A287A818198E380C52BA45A9693474FAB27A175C00B5ABF8.
	- Derive an IV using the shared secret as secret, and "IV-GENERATIONUyjRqTQ2n_diimbVKABLISsGv7CD9Lqcq7K0xzGqYtU" as info (in this text form!). The resulting IV is 852D1B4649F5F76C7339E093.
	- Encrypt the signature object using the derived key and IV, and using AAD2 as the AAD. the resulting encrypted text is: 
		```
		A9426972552E88F383B34293A1AB3EA837754F9FDDE9D6271FB94061A5CE57E50884802CAB7A92E95A01974E304E27E049D38BDBB03FC67C8C13B365E86CF4BB45729A833F034091503437405110A54D4E7D2DE25835161DA80F6B0DADADF456BF2ED75A85
		```
		The resulting tag is 9BBE19F557126FB2D71B878E0B943962.
- Build the JSON message, giving this representation (order and compact form are required): 
	```
	{"unprotected":{"clientExchangeId":"h2owbw","serverExchangeId":"S2Vgaw","nonce":"ooZ9U0dryUI","serverPubKey":{"x":"5NSem_HEr91xSCdlAXHrnGhnmXFIcX0-VjIhWBeFBeg","y":"gH7brq_q0neWgWJXxrqCeZxtWvmftM52koQWZNQQYr8"}},"ciphertext":"qUJpclUuiPODs0KToas-qDd1T5_d6dYnH7lAYaXOV-UIhIAsq3qS6VoBl04wTifgSdOL27A_xnyME7Nl6Gz0u0VymoM_A0CRUDQ3QFEQpU1OfS3iWDUWHagPaw2trfRWvy7XWoU","tag":"m74Z9VcSb7LXG4eOC5Q5Yg"}
	```
- Send the message as payload of the response. 

### Request 2 (Message 3)
The client concludes the exchange by sending a POST request to /clients/\<clientId\>/sessions/keyExchangeEnd with the following payload:
```
{
	"unprotected": {
		"serverExchangeId": BASE64URL_ENCODE(<server exchange id>),
		"nonce": BASE64URL_ENCODE(<nonce>)
	},
	"ciphertext": BASE64URL_ENCODE(<ciphertext>),
	"tag": BASE64URL_ENCODE(<tag>)
}
```
The serverExchangeId is the 32 bits integer value received in the previous response.
The nonce is a 64 bits new, unique and random value. 
the tag is generated by the encryption.
The **ciphertext** is the encrypted message which in its decrypted form is of the form:
```
{
	"r": BASE64URL_ENCODE(<r>),
	"s": BASE64URL_ENCODE(<s>)
}
```
The signature consists in the AAD3 value, signed with the permanent private key of the client and encoded using the two "r" and "s" values of the signature.

#### Message Generation
The message 3 is generated by the client by following these steps: 
- Check the integrity and authenticity of message2 by recreating AAD2, deriving the key and IV from the shared key the same way it was done for message2. 
	- Decrypt the encrypted part of the message, checking it using the associated tag. 
	- Verify the signature using the (permanent) public key of the server. 
- Reuse the server exchange id received and encoding it. 
- Generate a random 8 bytes nonce value and encode it.
- Calculate the shared key from the ephemeral public key of the server and the ephemeral private key of the client. 
- Define the AAD3 as SHA256(BASE64URLENCODE(AAD2) | \<unprotected message 3\>). The AAD2 used for message 2 is reused and the unprotected part of message 3 is concatenated to it, then the string is hashed. 
- Generate the signature, extract the "r" and "s" elements, encode it in base64url and create the JSON object with it, in a compact format. The signed data is the AAD3, and is signed with the (permanent) private key of the client. 
- Generate the data encryption:
	- Derive a key of length 256 bits from the shared key using HKDF with no salt, and the context info: "GCM256ENCRYPTION" | BASE64URLENCODE(\<AAD3\>). ( | represents concatenation). 
	- Derive an IV of length 96 bits using the same method and the same shared key with context info "IV-GENERATION" | BASE64URL_ENCODE(\<AAD3\>).
	- Use the AAD3 generated above as the encryption AAD. 
	- Encrypt the signature object, encode it in base64url format, and put it in the JSON object.
	- Add the base64url encoded tag of the encryption (it is of size 128 bits).

#### Example
- The verification of message 2 is done by reconstructing each element allowing for the signature decryption and verification. Once the message 2 is verified the client constructs message 3.
- Generate nonce: 553B3D139633EA94.
- Calculate the shared secret: 5F37F8C58BB59A9A6F37B82B831E3834B1956C9265A83013040A53405FB2F32B.
- Calculate the AAD3 by using SHA256 on the string
	 ```
	UyjRqTQ2n_diimbVKABLISsGv7CD9Lqcq7K0xzGqYtU{"serverExchangeId":"S2Vgaw","nonce":"VTs9E5Yz6pQ"}
	```
	The string is shown here without surrounding quotes.  
	- The resulting AAD3 is 6ED45F2AE16D20E2315A197AB00F151FA9341B5B16FA52E67AC921F467099BB0.
- Sign the AAD3 with the main private key. The signature cannot be determined in advance, so only an example of possible values is shown: 
	- "r" is 99BA5239D76145B0C42BD8EE9720FAE73A141670BA030D4E87A48E5084E6BC96.
	- "s" is 5E77E3C80844599F2C6B2C15670C3004234F97A940B50041DDB5C15BE01A7A71.
	- The resulting JSON object is (order and compact form are required):
		```
		{"r":"mbpSOddhRbDEK9julyD65zoUFnC6Aw1Oh6SOUITmvJY","s":"XnfjyAhEWZ8saywVZwwwBCNPl6lAtQBB3bXBW-AaenE"}
		```
- Encrypt the signature object:
	- Derive an encryption key using the shared secret as secret, and "GCM256ENCRYPTIONbtRfKuFtIOIxWhl6sA8VH6k0G1sW-lLmeskh9GcJm7A" as info (in this text form!). The resulting encryption key is 4095C6B812B2C1740427990CD7F66F9C73B32A5AE19C01C59EF63E7BBBB3AC87.
	- Derive an IV using the shared secret as secret, and "IV-GENERATIONbtRfKuFtIOIxWhl6sA8VH6k0G1sW-lLmeskh9GcJm7A" as info (in this text form!). The resulting IV is D735E59C1AAE007559E95163.
	- Encrypt the signature object using the derived key and IV, and using AAD3 as the AAD. the resulting encrypted text is: 
		```
		591D925EF3262B383547ED140270A2401C8BF4627B73D1DF61F62A8B237ECAF6761314299731958CF9846533EFC6E484048FBEF30E349B882D1F43F1B5DB9EFCC79A2D2B76079D3B92E0393BA7BE12A544B00027B8CF15202D717B48E08900928A0AD6C178
		```
		The resulting tag is 59B940D77CB7FAE13648329B62AEE6EF.
- Build the JSON message, giving this representation (order and compact form are required): 
	```
	{"unprotected":{"serverExchangeId":"S2Vgaw","nonce":"VTs9E5Yz6pQ"},"ciphertext":"WR2SXvMmKzg1R-0UAnCiQByL9GJ7c9HfYfYqiyN-yvZ2ExQplzGVjPmEZTPvxuSEBI--8w40m4gtH0Pxtdue_MeaLSt2B507kuA5O6e-EqVEsAAnuM8VIC1xe0jgiQCSigrWwXg","tag":"WblA13y3-uE2SDKbYq7m7w"}
	```
- Send the message as payload of the request. 

### Response 2 (End of Protocol)
#### Message Verification
In order to validate the exchange, the server must complete the following verification steps:
- Check the integrity and authenticity of message2 by recreating AAD3, deriving the key and IV from the shared key the same way it was done for message2. 
	- Decrypt the encrypted part of the message, checking it using the associated tag. 
	- Verify the signature using the (permanent) public key of the client. 

The server responds with a status code 200 or 401 if one of the verification steps failed. There is no payload. The server response is not encrypted and thus not trusted, in case the exchange failed then the client will just realize it during its first session request and start a new exchange in order to create a new session.

### Shared Secret Derivation
The shared secret is not used as is but is derived just as were the encryption key and IV for the exchange. The shared secret that will be used by both parties is derived using the same method as for the exchange, and by using "SESSION-KEY" | BASE64URLENCODE(AAD3), where AAD3 is the aad from message 3.

#### Example
- The derivation secret is the shared key. 
- The derivation info is "SESSION-KEYbtRfKuFtIOIxWhl6sA8VH6k0G1sW-lLmeskh9GcJm7A" (in this text form!). 
- The resulting session key that will be stored by both parties to encrypt and decrypt session messages is: C08BD0242126C56C8969E5CAC15FBB8E9F118D566B72A609F3D6601E6E1BACCB.


## Communication Using Session Keys
This type of communication assumes that the client and the enclave generated a shared and still valid session key. Normal messages exchange is done using symmetric encryption. Each request includes an "Authorization" header with a JWT (based on a JWE) token that authenticated the client. If present, the request payload is another JWE with normal serialization. For now, the encryption suite is considered fixed: AES-GCM 256 bits. The key size is 256 bits, the IV size is 96 bits and the tag length is 128 bits. A session is considered valid until either side decides to invalidate it. For each request, the used Initialization Vectors (IVs) must have a higher value that the ones used before. This is both a security measure and a way to ensure the order of the messages. 

### Authentication Token
The authenticating JWT is a JWE, present in the Authentication header of any request (Authorization: Bearer \<token\>). It is of the form:
```
BASE64URL-ENCODE(UTF8(JWE Header)) .
.
BASE64URL-ENCODE(JWE Initialization Vector) .
BASE64URL-ENCODE(JWE Claims) .
BASE64URL-ENCODE(JWE Authentication Tag)
```
The empty line is present because the JWT uses direct encryption, to no Content Encryption Key (cek) is present. The JWE header is defined as:
```
{"alg": "dir", "kid": <session key ID>, "cid": <client ID>}
```
The JWE claims set is defined (in its plaintext form) as: 
```
{
	"cid": <client ID>, 
	"mag": BASE64URL-ENCODE(<tag of message payload>)
}
```
The Message Tag (MAG) is only present in the case of a request containing a payload, and is used to link the header token to the request body. The IV must be higher that the ones used for previous messages of the same session, and must be higher than the one used for the request payload if present. The AAD used to generate the JWT consist in \<REST method\>:\<request path\>, for instance "GET:/clients/0123". They provide a check for any information that is not already included inside the header or the payload of the request, so that the enclave does not rely on any information given by the untrusted server only. 

### Message payload
If a payload is present in a request, it is represented as a JWE using flattened serialization. It is of the form: 
```
{
	"header": {"alg": "dir", "kid": <session key id>}, 
	"iv": BASE64URL-ENCODE(<iv>), 
	"ciphertext": BASE64URL-ENCODE(<ciphertext>), 
	"tag": BASE64URL-ENCODE(<tag>)
}
```
The Key ID (KID) is the same as the one used by the token. the IV value must be higher than the one used for the token. No AAD is used for the payload. The "tag" field is the one re-used by the authentication header as the "mag". The plaintext corresponding to the ciphertext is a JSON message containing the message from the client to the server, and are the ones described in the swagger API doc. 

### Server Response
The enclave provides a response for each request. It is always a JWE in the response payload, in the form:
```
{
	"header": {"alg": "dir", "kid": <session key id>}, 
	"iv": BASE64URL-ENCODE(<iv>), 
	"ciphertext": BASE64URL-ENCODE(<ciphertext>), 
	"tag": BASE64URL-ENCODE(<tag>)
}
```
The only exception is when there was no legitimate message sent to the server, in which case the server returns a code 401 Unauthorized, with no encrypted content. The IV must be greater than the ones used for the request. 
The ciphertext (in its plaintext form) consists in a JSON of the form:
```
{
	"mag": BASE64URL-ENCODE(<client's request authentication header tag>), 
	"message": <messsage>
}
```
The "message" field is not necessarily present. The AAD consist in the three digits string response code of the server (e.g. "201", "404").


## Proposed REST API
The REST API spec is provided in a separate document. In addition to HTTP status codes described in the document, each request can result in a **401** (unauthorized) response code with no response payload. This means the server was not able to decrypt the request, meaning either that an unauthorized client tried to make the request, or that the session key validity has expired. 
One note: the eventType and actionType resources provide a schema for event and action resources. However, there is no real obligation to check whether events and actions correspond to declared schemas. These resources can be seen as a way to simply categorize events and actions.

## Requirements for a Front-End Application
The system is based on the idea that the clients' privacy is assured, and that it is possible to prove it. Specifically, no code logic can ever be applied on clear data in untrusted platforms (any remote server). For the middleware this is solved by the use of attested SGX enclaves. On the client side, no particular architecture such as SGX is needed to guarantee privacy; the application logic consists of JS scripts running on the clients' machines and thus accessible to them. Because of that, the JS app is automatically trusted as it can be inspected by the clients. What differs from most JS apps is that **no client-related data can be stored in the clear on the server hosting the JS app**. Namely, any app configuration and meta data (e.g. the position of GUI elements) must be encrypted (using any encryption scheme as long as it is secure) before it is sent from the app to the untrusted server. One such example is that the client's private key cannot be stored on the server, and must be provided to the JS app by the user (file, manual input, ...). The front-end client must follow the specification described in this document. Other than that, there is no restriction on the extra possibilities and design of the application. Any extension to the current system can be done. If they require no server-side computation, the data containing extra features can be stored encrypted on the application server (e.g. GUI configuration). It is also possible to extend the current back-end system (enclave code), with discussion, to implement interesting new features. 

## Example Requests

### Request and Response
The following example shows how a request is constructed, sent, treated and responded to. In this example, a sensor client wants to post a new event to the enclave. 
- The client has the clientId 1, keyId 2, and uses eventTypeId 3. 
- The client wants to send the following properties: {"temperature": 20, "humidity": 35}.
- The hexadecimal representation of the session key is "60322a132f263fd64bd9dc6cdfb8c7512e7d093913d84baf7f986a10a4ef8692".
- The hexadecimal representation of the IV used for the message encryption is "0123456789abcdef01234568".
- The hexadecimal representation of the IV used for the authorization header encryption is "0123456789abcdef01234567". 

The client's procedure is as follow:
- The client creates the JSON object to be encrypted: 
	```
	{"clientId": 1, "eventTypeId": 3, "properties": {"temperature": 20, "humidity": 35}, "timestamp": "2018-06-03T14:34:46Z"}
	```
- The client creates the resulting JWE, which will be the payload of the request. Here is its representation: 
	```
	{
		"header": {"alg": "dir, "kid": 2},
		"ciphertext": "S0bi2ewjPc0H4wRl2wZkooBHajm1Zq3qozjX3ztTqsQkdbSP8jf-Blc2eg5iW3LfGq_yoeaR6yS1ZE1KHWyHWGNS4mrgaRJyScsFG8D7WGW_pmq_m9Ll0mdlN9IfqI-cPdr5XH--w_wS4IZXqbSsB8xY8NhbLYrclg", 
		"iv": "ASNFZ4mrze8BI0Vo", 
		"tag": "bokul3qgy5MQNnNnzlUBPQ"
	}
	```
- The client creates the JWT authentication header. The plaintext of the JWT claims is:
	 ```
	{"cid": 1, "mag": "bokul3qgy5MQNnNnzlUBPQ"}
	```
	The header if the JWT is (in JSON form):
	```
	{"alg": "dir", "kid": 2, "cid": 1}
	```
	The AAD are "POST:/events".
- Encrypting this payload, the resulting JWT is: 
	```
	eyJhbGciOiAiZGlyIiwgImtpZCI6IDIsICJjaWQiOiAxfQ..ASNFZ4mrze8BI0Vn.R7i2ZTomsmepayWtwZo-byrkmiGB9lymKb0nzXN7jrZR5ygPlaZOVF-mOQ.hD-VjO8oSIlOfpNM0UDdKw
	```
- The client sends a POST request to http://myapiaddress.com/api/events, using the generate JWT as a Bearer token in the headers (Authorization: Bearer \<token\>)

The server receives the request. Here is its procedure: 
- The server decodes the BASE64URL JWT fields.
- The server looks for a clientId and key ID matching those present in the JWT header.
- The server decrypts the JWT, and checks the validity of the cipher using the tag and the AAD. 
- The server now has authenticated the client. 
- The server checks that the "mag" of the JWT corresponds to the tag of the payload JWE.
- The server decrypts the payload and checks its integrity using the tag. 

At this point, the server can interpret the request (in this case create a new event). The server now creates a response as follow: 
- The server uses the same key and increments the IV by 1 ("0123456789abcdef01234569" in hexadecimal representation).
- The plaintext JSON the server will encrypt is: 
	```
	{"mag": "bokul3qgy5MQNnNnzlUBPQ", "message": {"id": 90, "clientId": 1, "eventTypeId": 3, "properties": {"temperature": 20, "humidity": 35}, "timestamp": "2018-06-03T14:34:46Z"}}
	```
- The server uses "201" as the AAD since it successfully created the resource.
- The resulting encoded JWE is:
	```
	{
		"header": {"alg": "dir, "kid": 2},
		"ciphertext": "69LOrohk1t7b0c3uAtzEJpT9b5X5soXfgy6wqYq_HQE_q4xvKisovXZ9tx9mJwRwHdbpDexK6XZuZ0xlnSuNDVqUg7cd86nuY8-0qoEjH6EaxH_ErSdIhn5FXkzbWvWtMa6pQL_EgSnPthAV1i1_X0hB-z0YesWfj04bAtVTj0RoN8SV2ll17iCqRC_d-VqkfF_Bl9Javw5LkxCiPL_Jgu-gFJYPmDjJYMl0ZM73-oG4", 
		"iv": "ASNFZ4mrze8BI0Vp", 
		"tag": "EZGftO8x2pwMz5mZBnLV6g"
	}
	```
The last step is for the client to check the response: 
- The client decrypts the message, checking its integrity using the tag and the response code as the AAD.
- The client checks that the message contains a "mag" field corresponding to its request tag. 
- The client deals with the response (in this case nothing to do, except increment the IV).

### API Resources
This example shows how to use the different resources of the API. Note that all the requests described here only show the decrypted payload of each request, and completely omit the encryption part that is systematically present.  We suppose we have an admin with ID 1, and a sensor client with ID 2. We also suppose that all registered clients have established a session key with the enclave. Each request is shown in one line, optionally followed by the payload description.
- The admin adds a new client that will act as an actuator: POST /clients
	```
	{
		"name": "actuator1",
		"pubKey": "xyzabc",
		"isAdmin": false,
		"isActive": false
	}
	```
	Server sends code 201, with new resource having ID 3.
- The admin wants to activate this client: PUT /clients/3
	```
	{
		"isActive": true
	}
	```
	Server sends code 200 with no content.
- The admin adds a new event type: POST /eventTypes
	```
	{
		"name": "temperatureEvent",
		"schema": {
			"type": "object",
			"properties": {
				"temperature": {
					"type": "integer"
				}
			},
			"required": ["temperature"]
		}
	}
	```
	The server sends code 201, with resource having ID 1. 
- The admin adds a new action type: POST /actionTypes
	```
	{
		"name": "TemperatureAction",
		"schema": {
			"type": "object",
			"properties": {
				"temperature": {
					"type": "integer"
				},
				"message": {
					"type": "string"
				}
			},
			"required": ["temperature"]
		}
	}
	```
	The server sends code 201, with resource having ID 1.
- The admin adds a new rule so that each time client 2 sends a temperature value higher that 25, the client 3 is notified: POST /rules
	```
	{
		"eventTypeIds": [1],
		"sourceClientIds": [2],
		"function": "if(event.temperature > 25){return {temperature: event.temperature, message: \"It's gonna be hot today!\"}}else{return null}",
		"actionTypeIds": [1],
		"destClientIds": [3],
		"destUrlIds": [],
		"isActive": true
	}
	```
	The server sends code 201, with rule having ID 1. 
- The sensor client adds a new event: POST /events
	```
	{
		"clientId": 2,
		"eventTypeId": 1,
		"properties": {"temperature": 26},
		"timestamp": "2018-06-03T14:34:46Z"
	}
	```
	The server sends code 201 with event having ID 1.
- The actuator client randomly checks its action messages: GET /clients/3/actionMessages
	The server sends code 200 with the following payload (response payload was omitted for previous requests):
	```
	[
		{
			"id": 1,
			"eventId": 1,
			"ruleId": 1,
			"actionTypeId": 1,
			"message": {
				"temperature": 26,
				"message": "It's gonna be hot today!"
			},
			"destClientId": 3,
			"completionTime": null
		}
	]
	```
- The actuator client notifies the server that he received the action: PUT /clients/3/actionMessages/1
	```
	{
		"completionTime": "2018-06-03T15:37:24Z"
	}
	```
	The server sends code 200. 

This peculiar way of acknowledging actions is used in order to respect the RESTful principles (a GET is idempotent, a POST creates a resource, etc.).
## References
- JWT: 
https://tools.ietf.org/html/rfc7519
- JWE: 
https://tools.ietf.org/html/rfc7516
- JSON Schema: 
https://spacetelescope.github.io/understanding-json-schema/index.html
- ECDHOC: 
https://tools.ietf.org/html/draft-selander-ace-cose-ecdhe-06
